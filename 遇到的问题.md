## 1. 如何设计一个线程管理一个事务
首先就是在事务调用时需要确保是对应线程调用，如果不是对应线程调用，则将其放入事务队列，由 epoll 唤醒对应线程去调用，还有在每次进行事务之前使用 assert 判断线程和事务是对应的

## 2. 防止悬空指针
由于高并发系统中事务处理常是异步执行的，如果在异步任务尚未完成时连接关闭导致 Channel 被销毁，那么异步回调中若仍访问这些对象，就会出现悬空指针访问的问题
在异步事件回调期间将弱引用提升为强引用，临时延长连接的生命周期，避免事件循环访问已释放对象导致崩溃

## 3. 定时器重复触发导致对象被多次销毁
由于每个定时器对象内部都持有 HttpServer 的句柄（或回调引用），在连接关闭流程中未能正确解除与定时器的关联，导致 HttpServer 对象在连接关闭后并未被完全释放。当定时器再次触发时，回调仍然访问已经被销毁或处于非法状态的对象，最终引发多次执行关闭逻辑并导致 core dump。

修复方案：
在为连接重新关联定时器时，先显式销毁此前已关联的定时器；同时，在销毁 HttpServer 对象时，若其仍存在关联的定时器，应一并取消并释放该定时器，确保对象生命周期与定时器生命周期严格一致，从而避免重复触发和悬空回调问题。

## 4. 客户端 read 时大量返回 104 错误
该问题表现为客户端在执行 read 操作时频繁返回 104（Connection reset by peer），表明连接在客户端读取数据前已被服务端重置。初期从业务处理流程入手排查，未发现明显逻辑错误。

在进一步定位过程中，通过调整服务器线程数进行对比测试发现：当线程数设置为 1～2 时问题不再复现，而当线程数提升至 3 个及以上 时，错误重新出现，并且各线程触发 104 错误的数量高度一致。该现象提示问题并非出现在具体业务逻辑中，而是与并发控制相关。

最终确认问题根因在于 服务器连接数阈值控制逻辑：当当前连接数超过设定阈值时，服务端会直接关闭新建立的连接。然而，该连接数判断与关闭操作并非原子执行。在高并发场景下，大量客户端在 TCP 连接刚建立后便立即发送数据，而此时服务端可能在尚未完成完整的连接管理流程前就关闭了连接，从而导致客户端在 read 阶段收到连接重置错误。

修复方案：
按照 muduo 的方案，对超过服务器荷载的请求进行优雅的关闭
